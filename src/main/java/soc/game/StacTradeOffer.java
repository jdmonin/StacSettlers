/**
 * Created by STAC project, University of Edinburgh.
 */

package soc.game;

import java.util.Arrays;
import soc.debug.D;

/**
 * Subclass of SOCTradeOffer that knows disjunctive resource sets.
 * These are needed for the chat trading, where the specified resources can be disjunctive in addition to the standard conjunctive interpretation.
 * @author Markus Guhe <m.guhe@ed.ac.uk>
 */

/**
 *
 * @author markus
 */
public class StacTradeOffer extends SOCTradeOffer{
    
    private final boolean disjunctiveGive;
    private final boolean disjunctiveGet;
    
    /**
     * Designated initialiser.
     * @param game      the game name
     * @param from      offering player
     * @param to        receivers of the offer
     * @param give      givable resources
     * @param disjGive  flag indicating whether the give set represents a disjunction of the specified resources
     * @param get       receivable resources
     * @param disjGet   flag indicating whether the get set represents a disjunction of the specified resources
     */
    public StacTradeOffer(String game, int from, boolean[] to, SOCResourceSet give, boolean disjGive, SOCResourceSet get, boolean disjGet) {
        super(game, from, to, give, get);
        disjunctiveGive = disjGive;
        disjunctiveGet = disjGet;

        //99 is sometimes used as placeholder for an undidentified player
        if (from != 99 && to[from]) {
            String out = "Error in StacTradeOffer 'from' cannot also be set in 'to[]'!\n";
            for (StackTraceElement trace : Thread.currentThread().getStackTrace()) {
                out += "\t" + trace + "\n";
            }
            D.ebugERROR(out);
        }
    }

    /**
     * Convenience method to convert SOCTradeOffer into a StacTradeOffer.
     * Copies the objects in offer (like the SOCTradeOffer constructor does).
     * Information about disjunctive resource sets is set to false.
     * @param offer SOCTradeOffer to be converted into a StacTradeOffer
     */
    public StacTradeOffer(SOCTradeOffer offer) {
        this(offer.getGame(), offer.getFrom(), Arrays.copyOf(offer.getTo(), offer.getTo().length),
                offer.getGiveSet().copy(), false, offer.getGetSet().copy(), false);
    }
    /**
     * @return whether the offer's give set is disjunctive
     */
    public boolean hasDisjunctiveGiveSet() {
        return disjunctiveGive;
    }

    /**
     * @return whether the offer's get set is disjunctive
     */
    public boolean hasDisjunctiveGetSet() {
        return disjunctiveGet;
    }
    

    @Override
    public boolean equals(Object o) {
    	if (o instanceof StacTradeOffer) {
    		StacTradeOffer offer = (StacTradeOffer) o;
    		for (int i=0; i < to.length; i++) {
    			if (to[i]!=offer.to[i]) {
    				return false;
    			}
    		}
    		return (from == offer.from
    				&& give.equals(offer.give)
                    && disjunctiveGive == offer.disjunctiveGive
    				&& get.equals(offer.get)
                    && disjunctiveGet == offer.disjunctiveGet);
    	}
    	else {
    		return false;
    	}
    }

    /**
     * This was automatically generated by Netbeans.
     * @return 
     */
    @Override
    public int hashCode() {
        int hash = 7;
        hash = 29 * hash + (this.disjunctiveGive ? 1 : 0);
        hash = 29 * hash + (this.disjunctiveGet ? 1 : 0);
        return hash;
    }

    
    /**
     * Adapted from the super method to account for disjunctive resource sets.
     * @return a human readable string of data
     */
    @Override
    public String toString()
    {
        String str = "game=" + game + "|from=" + from + "|to=" + to[0];

        for (int i = 1; i < to.length; i++) {
            str += ("," + to[i]);
        }

        str += ("|give=" + give + "|disj=" + Boolean.toString(disjunctiveGive) + 
                "|get=" + get +  "|disj=" + Boolean.toString(disjunctiveGet));

        return str;
    }
    

    /**
     * Parsing of the standard toString() result.
     * Adapted from the SOCTradeOffer method.
     * General format of the string represenation:
     * game=Practice 0|from=0|to=false,false,true,true|give=clay=0|ore=0|sheep=1|wheat=0|wood=0|unknown=0|disjunctive=false|get=clay=0|ore=0|sheep=0|wheat=1|wood=0|unknown=0|disjunctive=false
     * @param s
     * @return
     * Note: Trade offer message has something like this, but that logic should have been here
     */
    public static StacTradeOffer parse(String s) {    	
        String pieces[] = s.split("\\|");
        String game = pieces[0].split("=")[1];
        int from = Integer.parseInt(pieces[1].split("=")[1]);
        boolean to[] = new boolean[4];
        String pt[] = pieces[2].split("=")[1].split(",");
        for (int i=0; i<4; i++) {
            to[i] = Boolean.parseBoolean(pt[i]);
        }
        
       
        SOCResourceSet giveSet = new SOCResourceSet();
        // special handling of clay due to give=clay=n
        int rc = Integer.parseInt(pieces[3].split("=")[2]);
        giveSet.add(rc,1);
        for (int i=1; i<6; i++) {
            rc = Integer.parseInt(pieces[3+i].split("=")[1]);
            giveSet.add(rc, i+1);
        }
        if (!pieces[9].startsWith("disj=")) {
            if (pieces[9].startsWith("get=clay=")) {
                D.ebugERROR("Parsing give set in a trade offer. This seems to be a SOCTradeOffer - please amend your code to call SOCTradeOffer.parse()!" +
                        "\n\tThe string is: " + s);
            } else {
                D.ebugERROR("Parsing give set in a trade offer. Don't know what is wrong with this string!" +
                        "\n\tThe string is: " + s);
            }
        }
        boolean disjGive = Boolean.parseBoolean(pieces[9].split("=")[1]);
        
        SOCResourceSet getSet = new SOCResourceSet();
        // special handling of clay due to give=clay=n
        rc = Integer.parseInt(pieces[10].split("=")[2]);
        getSet.add(rc,1);
        for (int i=1; i<6; i++) {
            rc = Integer.parseInt(pieces[10+i].split("=")[1]);
            getSet.add(rc, i+1);
        }
        boolean disjGet = Boolean.parseBoolean(pieces[16].split("=")[1]);
        
        return new StacTradeOffer(game, from, to, giveSet, disjGive, getSet, disjGet);
    }

    /**
     * Create a new StacTradeOffer where 'to' is the original 'from' and give and get sets are exchanged.
     * @param newFrom       the number of the new offering player
     * @return              the inverted offer
     */
    @Override
    public StacTradeOffer invertedOffer(int newFrom) {
        boolean[] newTo = new boolean[to.length];
        newTo[from] = true;
        StacTradeOffer invertedOffer = new StacTradeOffer(game, newFrom, newTo, get, disjunctiveGet, give, disjunctiveGive);
        return invertedOffer;
    }
    
    /**
     * Is this offer a partial offer, i.e. is the give set or the get set empty?
     * @return  flag whether this is a partial offer
     */
    public boolean isPartialOffer() {
        //written this way in the hope of better performance rather than calling equal()
        return
                (give.resources[SOCResourceConstants.CLAY]      == 0 
                && give.resources[SOCResourceConstants.ORE]     == 0
                && give.resources[SOCResourceConstants.SHEEP]   == 0
                && give.resources[SOCResourceConstants.WHEAT]   == 0
                && give.resources[SOCResourceConstants.WOOD]    == 0
                && give.resources[SOCResourceConstants.UNKNOWN] == 0)
            ||
                (get.resources[SOCResourceConstants.CLAY]      == 0 
                && get.resources[SOCResourceConstants.ORE]     == 0
                && get.resources[SOCResourceConstants.SHEEP]   == 0
                && get.resources[SOCResourceConstants.WHEAT]   == 0
                && get.resources[SOCResourceConstants.WOOD]    == 0
                && get.resources[SOCResourceConstants.UNKNOWN] == 0);
    }
    
}
